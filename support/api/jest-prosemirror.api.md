## API Report File for "jest-prosemirror"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { CommandFunction } from '@remirror/core';
import { DirectEditorProps } from 'prosemirror-view';
import { EditorSchema } from '@remirror/core';
import { EditorState } from 'prosemirror-state';
import { EditorStateParams } from '@remirror/core';
import { EditorView } from 'prosemirror-view';
import { EventType as EventType_2 } from '@testing-library/dom';
import { GapCursor } from 'prosemirror-gapcursor';
import { InputRule } from '@remirror/core';
import { PlainObject } from '@remirror/core';
import { Plugin } from '@remirror/core';
import pm from 'prosemirror-test-builder';
import { PosParams } from '@remirror/core';
import { Schema } from 'prosemirror-model';
import { Selection } from 'prosemirror-state';
import { SelectionParams } from '@remirror/core';
import { TaggedProsemirrorNode } from 'prosemirror-test-builder';
import { TextParams } from '@remirror/core';

// @public (undocumented)
export const a: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedFlatObject<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public
export const apply: <GSchema extends import("prosemirror-model").Schema<string, string> = any>(taggedDoc: TaggedProsemirrorNode<GSchema>, command: CommandFunction<GSchema>, result?: TaggedProsemirrorNode<GSchema> | undefined) => ApplyReturn<GSchema>;

// @public
export interface ApplyReturn<GSchema extends EditorSchema = any> extends TaggedDocParams<GSchema>, EditorStateParams<GSchema> {
    pass: boolean;
}

// @public (undocumented)
export const atomBlock: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const atomContainer: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const atomInline: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const blockquote: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const code: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedFlatObject<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const codeBlock: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public
export interface CommandTransformation<GSchema extends EditorSchema = any> {
    from: TaggedProsemirrorNode<GSchema>;
    to?: TaggedProsemirrorNode<GSchema>;
}

// @public (undocumented)
export const containerWithRestrictedContent: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public
export const createEditor: <GSchema extends import("prosemirror-model").Schema<string, string> = any>(taggedDoc: TaggedProsemirrorNode<GSchema>, { plugins, rules, autoClean, ...editorOptions }?: CreateEditorOptions) => {
    start: number;
    end: number;
    selection: import("prosemirror-state").Selection<GSchema>;
    schema: GSchema;
    state: import("prosemirror-state").EditorState<GSchema>;
    view: TestEditorView<GSchema>;
    overwrite: (newDoc: TaggedProsemirrorNode<GSchema>) => any;
    command: (command: CommandFunction<any>) => any;
    insertText: (text: string) => any;
    jumpTo: (start: number | "end" | "start", end?: number | undefined) => any;
    shortcut: (mod: string) => any;
    press: (char: string) => any;
    fire: (params: Pick<FireEventAtPositionParams<GSchema>, "position" | "options" | "event">) => any;
    callback: (fn: (content: ReturnValueCallbackParams<GSchema>) => void) => any;
};

// @public (undocumented)
export interface CreateEditorOptions extends Omit<DirectEditorProps, 'state'> {
    autoClean?: boolean;
    plugins?: Plugin[];
    rules?: InputRule[];
}

// @public (undocumented)
export const createEvents: <GEvent extends Event>(event: EventType, options: PlainObject) => GEvent[];

// @public
export const createState: <GSchema extends Schema<string, string> = any>(taggedDoc: pm.TaggedProsemirrorNode<GSchema>, plugins?: import("prosemirror-state").Plugin<any, any>[]) => EditorState<GSchema>;

// @public
export const dispatchAllSelection: <GSchema extends import("prosemirror-model").Schema<string, string> = any>({ view, }: TestEditorViewParams<GSchema>) => void;

// Warning: (ae-forgotten-export) The symbol "DispatchNodeSelectionParams" needs to be exported by the entry point index.d.ts
// 
// @public
export const dispatchNodeSelection: <GSchema extends import("prosemirror-model").Schema<string, string> = any>({ view, pos, }: DispatchNodeSelectionParams<GSchema>) => void;

// Warning: (ae-forgotten-export) The symbol "DispatchTextSelectionParams" needs to be exported by the entry point index.d.ts
// 
// @public
export const dispatchTextSelection: <GSchema extends import("prosemirror-model").Schema<string, string> = any>({ view, start, end, }: DispatchTextSelectionParams<GSchema>) => void;

// @public (undocumented)
export const doc: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const em: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedFlatObject<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// Warning: (ae-forgotten-export) The symbol "rawEventMap" needs to be exported by the entry point index.d.ts
// 
// @public (undocumented)
export type EventType = keyof typeof rawEventMap | 'doubleClick' | 'tripleClick';

// @public
export const findTextNode: (node: Node, text: string) => Node | undefined;

// @public
export const fireEventAtPosition: <GSchema extends import("prosemirror-model").Schema<string, string> = any>({ view, event, options, position, }: FireEventAtPositionParams<GSchema>) => void;

// @public (undocumented)
export interface FireParams {
    event: EventType_2;
    options?: PlainObject;
    position?: number;
}

// @public
export const flush: (view: TestEditorView<any>) => void;

// @public (undocumented)
export const h1: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const h2: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const h3: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const h4: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const h5: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const h6: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const hardBreak: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const heading: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const horizontalRule: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const image: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public
export const initSelection: <GSchema extends Schema<string, string> = any>(taggedDoc: pm.TaggedProsemirrorNode<GSchema>) => GapCursor | Selection<GSchema> | null;

// @public
export const insertText: <GSchema extends import("prosemirror-model").Schema<string, string> = any>({ view, text, start: from, }: InsertTextParams<GSchema>) => void;

// @public (undocumented)
export interface InsertTextParams<GSchema extends EditorSchema = any> extends TestEditorViewParams<GSchema>, TextParams {
    start: number;
}

// @public (undocumented)
export const li: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const link: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedFlatObject<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const ol: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const p: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const paragraph: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

export { pm }

// @public
export const pmBuild: <GObj extends Record<string, pm.NodeTypeAttributes | pm.MarkTypeAttributes> = Record<string, pm.NodeTypeAttributes | pm.MarkTypeAttributes>, GNodes extends string = string, GMarks extends string = string>(testSchema: Schema<GNodes, GMarks>, names: GObj) => Record<GNodes, (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<GNodes, GMarks>>> & Record<GMarks, (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedFlatObject<Schema<GNodes, GMarks>>> & { [P in keyof ({
    doc: {
        nodeType: string;
    };
    p: {
        nodeType: string;
    };
    text: {
        nodeType: string;
    };
} & GObj)]: ({
    doc: {
        nodeType: string;
    };
    p: {
        nodeType: string;
    };
    text: {
        nodeType: string;
    };
} & GObj)[P] extends pm.NodeTypeAttributes ? (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<GNodes, GMarks>> : (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedFlatObject<Schema<GNodes, GMarks>>; };

// Warning: (ae-forgotten-export) The symbol "PressParams" needs to be exported by the entry point index.d.ts
// 
// @public
export const press: <GSchema extends import("prosemirror-model").Schema<string, string> = any>({ view, char }: PressParams<GSchema>) => void;

// @public (undocumented)
export const prosemirrorMatchers: {
    toTransformNode(this: jest.MatcherUtils, command: CommandFunction<any>, { from, to }?: CommandTransformation<any>): {
        message: () => string;
        pass: boolean;
    } | {
        pass: true;
        message: () => string;
        actual: TaggedProsemirrorNode<any>;
        expected: TaggedProsemirrorNode<any>;
        name: string;
    } | {
        pass: false;
        message: () => string;
        actual: TaggedProsemirrorNode<any>;
        expected: TaggedProsemirrorNode<any>;
        name: string;
    };
    toEqualProsemirrorNode(this: jest.MatcherUtils, actual: TaggedProsemirrorNode<any>, expected: TaggedProsemirrorNode<any>): {
        pass: boolean;
        actual: TaggedProsemirrorNode<any>;
        expected: TaggedProsemirrorNode<any>;
        message: () => string;
        name: string;
    };
};

// @public (undocumented)
export const schema: Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">;

// @public
export const selectionFor: <GSchema extends Schema<string, string> = any>(taggedDoc: pm.TaggedProsemirrorNode<GSchema>) => Selection<GSchema>;

// @public
export const setupProsemirrorEnvironment: () => void;

// Warning: (ae-forgotten-export) The symbol "KeyboardShortcutParams" needs to be exported by the entry point index.d.ts
// 
// @public
export const shortcut: <GSchema extends import("prosemirror-model").Schema<string, string> = any>({ view, shortcut: text, }: KeyboardShortcutParams<GSchema>) => void;

// @public (undocumented)
export const strong: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedFlatObject<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const table: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const tableCell: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const tableHeader: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const tableRow: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public
export const taggedDocHasSelection: (taggedDoc: pm.TaggedProsemirrorNode<any>) => boolean;

// @public (undocumented)
export interface TaggedDocParams<GSchema extends EditorSchema = any> {
    taggedDoc: TaggedProsemirrorNode<GSchema>;
}

// @public (undocumented)
export const td: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const tdCursor: pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const tdEmpty: pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export interface TestEditorView<GSchema extends EditorSchema = any> extends EditorView<GSchema> {
    // (undocumented)
    dispatchEvent(event: string | CustomEvent | {
        type: string;
    }): void;
    // (undocumented)
    domObserver: {
        flush: () => void;
    };
}

// @public (undocumented)
export interface TestEditorViewParams<GSchema extends EditorSchema = any> {
    view: TestEditorView<GSchema>;
}

// @public (undocumented)
export const text: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const th: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const thCursor: pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const thEmpty: pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const tr: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;

// @public (undocumented)
export const ul: (...args: (string | pm.TaggedProsemirrorNode<any> | pm.TaggedFlatObject<any>)[]) => pm.TaggedProsemirrorNode<Schema<"text" | "table" | "blockquote" | "image" | "doc" | "paragraph" | "heading" | "code_block" | "hard_break" | "table_cell" | "table_header" | "table_row" | "atomInline" | "atomBlock" | "containerWithRestrictedContent" | "orderedList" | "bulletList" | "listItem" | "horizontalRule" | "atomContainer", "link" | "code" | "em" | "strong">>;


// Warnings were encountered during analysis:
// 
// src/jest-prosemirror-editor.ts:311:7 - (ae-forgotten-export) The symbol "FireEventAtPositionParams" needs to be exported by the entry point index.d.ts
// src/jest-prosemirror-editor.ts:320:7 - (ae-forgotten-export) The symbol "ReturnValueCallbackParams" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
