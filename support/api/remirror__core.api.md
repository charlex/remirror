## API Report File for "@remirror/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ActionMethod } from '@remirror/core-types';
import { AnyActions } from '@remirror/core-types';
import { AnyConstructor } from '@remirror/core-types';
import { AnyFunction } from '@remirror/core-types';
import { AnyHelpers } from '@remirror/core-types';
import { AttrsWithClass } from '@remirror/core-types';
import { BaseExtensionOptions } from '@remirror/core-types';
import { CommandStatusCheck } from '@remirror/core-types';
import { CommandTypeParams } from '@remirror/core-types';
import { ComponentType } from 'react';
import { CreateDocumentNodeParams } from '@remirror/core-utils';
import { EditorSchema } from '@remirror/core-types';
import { EditorState } from 'prosemirror-state';
import { EditorStateParams } from '@remirror/core-types';
import { EditorView } from '@remirror/core-types';
import { ExtensionCommandReturn } from '@remirror/core-types';
import { ExtensionHelperReturn } from '@remirror/core-types';
import { ExtensionManagerInitParams } from '@remirror/core-types';
import { ExtensionManagerMarkTypeParams } from '@remirror/core-types';
import { ExtensionManagerNodeTypeParams } from '@remirror/core-types';
import { ExtensionManagerParams } from '@remirror/core-types';
import { ExtensionManagerTypeParams } from '@remirror/core-types';
import { ExtensionTags } from '@remirror/core-types';
import { ExtensionType } from '@remirror/core-constants';
import { InputRule } from 'prosemirror-inputrules';
import { Interpolation } from '@emotion/core';
import { Key } from '@remirror/core-types';
import { KeyboardBindings } from '@remirror/core-types';
import { MarkExtensionOptions } from '@remirror/core-types';
import { MarkExtensionSpec } from '@remirror/core-types';
import { MarkType } from '@remirror/core-types';
import { NodeExtensionOptions } from '@remirror/core-types';
import { NodeExtensionSpec } from '@remirror/core-types';
import { NodeType } from '@remirror/core-types';
import { NodeViewMethod } from '@remirror/core-types';
import { OnTransactionParams } from '@remirror/core-types';
import { PlainObject } from '@remirror/core-types';
import { PluginKey } from 'prosemirror-state';
import { PortalContainer } from '@remirror/react-portals';
import { ProsemirrorPlugin } from '@remirror/core-types';
import { RemirrorThemeContextType } from '@remirror/core-types';
import { Schema } from 'prosemirror-model';
import { StringKey } from '@remirror/core-types';
import { Suggester } from 'prosemirror-suggest';
import { Tags } from '@remirror/core-constants';
import { TransactionParams } from '@remirror/core-types';
import { UnionToIntersection } from '@remirror/core-types';

// @public
export type ActionNames<GExtension extends AnyExtension> = StringKey<ActionsFromExtensions<GExtension>>;

// @public
export type ActionsFromExtensions<GExtension extends AnyExtension> = UnionToIntersection<MapCommandToAction<GExtension['_C']>>;

// @public
export type AnyExtension = Extension<any, any>;

// @public
export type AnyExtensionManager = ExtensionManager<any>;

// @public
export type CommandsOfExtension<GExtension extends {
    commands?: any;
}> = GExtension['commands'];

// @public
export type DataOfExtension<GExtension extends {
    extensionData?: any;
}> = GExtension['extensionData'];

// @public
export class DocExtension extends NodeExtension<DocExtensionOptions> {
    // (undocumented)
    readonly defaultOptions: {
        content: string;
    };
    // (undocumented)
    readonly name: "doc";
    // (undocumented)
    readonly schema: NodeExtensionSpec;
}

// @public (undocumented)
export interface DocExtensionOptions extends NodeExtensionOptions {
    content?: string;
}

// @public
export abstract class Extension<GOptions extends BaseExtensionOptions, GType = never> {
    constructor(options?: GOptions);
    readonly _C: this['commands'] extends AnyFunction ? ReturnType<this['commands']> : {};
    protected readonly defaultOptions: Partial<GOptions>;
    protected extraAttrs(fallback?: string | null): Record<string, {
        default?: unknown;
    }>;
    protected getExtraAttrs(domNode: Node): Record<string, unknown>;
    readonly _H: this['helpers'] extends AnyFunction ? ReturnType<this['helpers']> : {};
    protected init(): void;
    abstract readonly name: string;
    readonly _O: GOptions;
    readonly options: Required<GOptions>;
    readonly pluginKey: PluginKey;
    readonly _T: GType;
    readonly tags: Array<Tags | string>;
    readonly type: ExtensionType;
}

// @public (undocumented)
export interface Extension<GOptions extends BaseExtensionOptions = BaseExtensionOptions, GType = never> {
    // @alpha
    attributes?(params: ExtensionManagerParams): AttrsWithClass;
    commands?(params: CommandTypeParams<GType>): ExtensionCommandReturn;
    extensionData?(params: ExtensionManagerTypeParams<GType>): PlainObject;
    helpers?(params: ExtensionManagerTypeParams<GType>): ExtensionHelperReturn;
    inputRules?(params: ExtensionManagerTypeParams<GType>): InputRule[];
    isActive?(params: ExtensionManagerParams): CommandStatusCheck<string>;
    isEnabled?(params: ExtensionManagerParams): CommandStatusCheck<string>;
    keys?(params: ExtensionManagerTypeParams<GType>): KeyboardBindings;
    // @alpha
    nodeView?(params: ExtensionManagerTypeParams<GType>): NodeViewMethod;
    onTransaction?(params: OnTransactionParams): void;
    pasteRules?(params: ExtensionManagerTypeParams<GType>): ProsemirrorPlugin[];
    plugin?(params: ExtensionManagerTypeParams<GType>): ProsemirrorPlugin;
    readonly requiredExtensions?: string[];
    ssrTransformer?(element: JSX.Element, params: ExtensionManagerParams): JSX.Element;
    styles?(params: ExtensionManagerParams): Interpolation;
    suggestions?(params: ExtensionManagerTypeParams<GType>): Suggester[] | Suggester;
}

// @public
export interface ExtensionConstructor<GOptions extends BaseExtensionOptions, GExtension extends Extension<GOptions, any>> {
    // (undocumented)
    new (options?: GOptions): GExtension;
}

// @public (undocumented)
export interface ExtensionListParams {
    extensions: AnyExtension[];
}

// @public
export class ExtensionManager<GExtension extends AnyExtension = any> implements ExtensionManagerInitParams<SchemaFromExtensions<GExtension>> {
    constructor(extensions: GExtension[]);
    // @internal
    readonly _A: ActionsFromExtensions<GExtension>;
    readonly attributes: AttrsWithClass;
    readonly components: Record<string, ComponentType<{}>>;
    static create<GFlexibleList extends FlexibleExtension[]>(prioritizedExtensions: GFlexibleList): ExtensionManager<import("./extension-types").InferFlexibleExtension<GFlexibleList[number]>>;
    createState({ content, doc, stringHandler, fallback }: Omit<CreateDocumentNodeParams, 'schema'>): EditorState<any>;
    // @internal
    readonly _D: ExtensionManagerData<this['_A'], this['_H'], this['_N'], this['_M'], this['_P']>;
    readonly data: this["_D"];
    // @internal
    readonly _E: GExtension;
    extensionData(): Record<string, PlainObject>;
    readonly extensions: GExtension[];
    getPluginState<GState>(name: this['_N']): GState;
    getState: () => EditorState;
    getTheme: () => RemirrorThemeContextType;
    // @internal
    readonly _H: HelpersFromExtensions<GExtension>;
    init({ getState, portalContainer, getTheme }: ExtensionManagerInitParams): this;
    readonly initialized: boolean;
    initView(view: EditorView<SchemaFromExtensions<GExtension>>): void;
    isEqual(otherManager: unknown): boolean;
    // @internal
    readonly _M: MarkNames<GExtension>;
    readonly marks: Record<this["_M"], MarkExtensionSpec>;
    // @internal
    readonly _N: NodeNames<GExtension>;
    // @internal
    readonly _Names: this['_P'] | this['_N'] | this['_M'];
    readonly nodes: Record<this["_N"], NodeExtensionSpec>;
    onTransaction(params: OnTransactionManagerParams): void;
    // (undocumented)
    readonly options: Record<NodeNames<GExtension> | MarkNames<GExtension> | PlainNames<GExtension>, PlainObject>;
    // @internal
    readonly _P: PlainNames<GExtension>;
    portalContainer: PortalContainer;
    readonly schema: Schema<NodeNames<GExtension>, MarkNames<GExtension>>;
    ssrTransformer(element: JSX.Element): JSX.Element;
    readonly tags: ExtensionTags<NodeNames<GExtension>, MarkNames<GExtension>, PlainNames<GExtension>>;
    readonly view: EditorView<SchemaFromExtensions<GExtension>>;
}

// @public (undocumented)
export interface ExtensionManagerData<GActions = AnyActions, GHelpers = AnyHelpers, GNodes extends string = string, GMarks extends string = string, GPlain extends string = string, GNames extends string = GNodes | GMarks | GPlain> {
    // (undocumented)
    actions: GActions;
    // (undocumented)
    directPlugins: ProsemirrorPlugin[];
    // (undocumented)
    helpers: GHelpers;
    // (undocumented)
    inputRules: ProsemirrorPlugin;
    // (undocumented)
    isActive: Record<GNames, CommandStatusCheck>;
    // (undocumented)
    isEnabled: Record<GNames, CommandStatusCheck>;
    // (undocumented)
    keymaps: ProsemirrorPlugin[];
    // (undocumented)
    nodeViews: Record<string, NodeViewMethod>;
    // (undocumented)
    options: Record<GNames, PlainObject>;
    // (undocumented)
    pasteRules: ProsemirrorPlugin[];
    // (undocumented)
    plugins: ProsemirrorPlugin[];
    // (undocumented)
    schema: EditorSchema<GNodes, GMarks>;
    // (undocumented)
    styles: Interpolation;
    // (undocumented)
    suggestions: ProsemirrorPlugin;
    // (undocumented)
    tags: ExtensionTags<GNodes, GMarks, GPlain>;
    // (undocumented)
    view: EditorView<EditorSchema<GNodes, GMarks>>;
}

// @public (undocumented)
export interface ExtensionParams<GExtension extends AnyExtension = any> {
    extension: GExtension;
}

// @public
export type ExtensionsFromManager<GManager extends AnyExtensionManager> = GManager['_E'];

// @public
export type FlexibleExtension<GExtension extends AnyExtension = any> = GExtension | PrioritizedExtension<GExtension>;

// @public (undocumented)
export type FlexibleExtensions<GExtensions extends AnyExtension[] = any[]> = Array<FlexibleExtension<GExtensions[number]>>;

// @public (undocumented)
export type FromFlexibleExtension<GValue extends FlexibleExtension<any>> = GValue extends PrioritizedExtension<infer P> ? P : GValue extends AnyExtension ? GValue : never;

// @public
export type HelperNames<GExtension extends AnyExtension> = StringKey<HelpersFromExtensions<GExtension>>;

// @public
export type HelpersFromExtensions<GExtension extends AnyExtension> = UnionToIntersection<MapHelpers<GExtension['_H']>>;

// @public
export type HelpersOfExtension<GExtension extends {
    helpers?: any;
}> = GExtension['helpers'];

// @public
export type InferFlexibleExtension<GFlexible extends FlexibleExtension<any>> = GFlexible extends PrioritizedExtension<any> ? GFlexible['extension'] : GFlexible extends AnyExtension ? GFlexible : never;

// @public
export type InferFlexibleExtensionList<GFlexibleList extends Array<FlexibleExtension<any>>> = InferFlexibleExtension<GFlexibleList[number]>;

// @public
export const isExtension: (extension: unknown) => extension is Extension<any, any>;

// @public
export const isExtensionManager: (value: unknown) => value is ExtensionManager<import("./extension").Extension<any, any>>;

// @public
export const isMarkExtension: (extension: unknown) => extension is MarkExtension<any>;

// @public
export const isNodeExtension: (extension: unknown) => extension is NodeExtension<any>;

// @public
export const isPlainExtension: (extension: unknown) => extension is Extension<any, never>;

// @public (undocumented)
export interface ManagerParams<GExtension extends AnyExtension = any> {
    manager: ExtensionManager<GExtension>;
}

// @public
export type MapCommandToAction<GCommands extends Record<string, AnyFunction>> = {
    [P in Key<GCommands>]: ActionMethod<Parameters<GCommands[P]>>;
};

// @public
export type MapHelpers<GHelpers extends Record<string, AnyFunction>> = {
    [P in Key<GHelpers>]: GHelpers[P];
};

// @public
export abstract class MarkExtension<GOptions extends MarkExtensionOptions = MarkExtensionOptions> extends Extension<GOptions, MarkType<EditorSchema>> {
    isActive({ getState, type }: ExtensionManagerMarkTypeParams): CommandStatusCheck;
    isEnabled(_: ExtensionManagerMarkTypeParams): CommandStatusCheck;
    abstract readonly schema: MarkExtensionSpec;
    readonly type: ExtensionType.Mark;
}

// @public
export type MarkNames<GExtension extends AnyExtension> = GExtension extends MarkExtension<any> ? GExtension['name'] : never;

// @public
export type NameOfExtension<GExtension extends AnyExtension> = GExtension['name'];

// @public
export abstract class NodeExtension<GOptions extends NodeExtensionOptions = NodeExtensionOptions> extends Extension<GOptions, NodeType<EditorSchema>> {
    // (undocumented)
    isActive({ getState, type }: ExtensionManagerNodeTypeParams): CommandStatusCheck;
    // (undocumented)
    isEnabled(_: ExtensionManagerNodeTypeParams): CommandStatusCheck;
    abstract readonly schema: NodeExtensionSpec;
    readonly type: ExtensionType.Node;
}

// @public
export type NodeNames<GExtension extends AnyExtension> = GExtension extends NodeExtension<any> ? GExtension['name'] : never;

// @public (undocumented)
export interface OnTransactionManagerParams extends TransactionParams, EditorStateParams {
}

// @public
export type OptionsOfExtension<GExtension extends {
    _O: any;
}> = GExtension['_O'];

// @public
export type PlainNames<GExtension extends AnyExtension> = ProsemirrorTypeOfExtension<GExtension> extends never ? GExtension['name'] : never;

// @public
export interface PrioritizedExtension<GExtension extends AnyExtension = any> {
    extension: GExtension;
    priority: number;
}

// @public
export type ProsemirrorTypeOfExtension<GExtension extends {
    _T: any;
}> = GExtension['_T'];

// @public
export type SchemaFromExtensions<GExtension extends AnyExtension = any> = EditorSchema<NodeNames<GExtension>, MarkNames<GExtension>>;

// @public
export class TextExtension extends NodeExtension {
    // (undocumented)
    readonly name: "text";
    // (undocumented)
    readonly schema: {
        group: string;
    };
}

// @public
export type TypeOfExtensionClass<GExtensionClass extends AnyConstructor, GExtension extends InstanceType<GExtensionClass> = InstanceType<GExtensionClass>> = GExtension extends AnyExtension ? GExtension : never;

// @public
export type TypeOfExtensionClassList<GExtensionConstructors extends AnyConstructor[]> = TypeOfExtensionClass<GExtensionConstructors[number]>;


export * from "@remirror/core-constants";
export * from "@remirror/core-helpers";
export * from "@remirror/core-types";
export * from "@remirror/core-utils";

// (No @packageDocumentation comment for this package)

```
